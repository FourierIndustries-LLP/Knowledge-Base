<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>From Blocks to Code, Part II - FourierIndustries Knowledge Base</title><meta name="description" content="In this tutorial, we are going to explore functions, understand&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><script type="text/javascript" async src="https://www.googletagmanager.com/gtag/js?id=G-YBTR3X59V9"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];
				  function gtag(){dataLayer.push(arguments);}
				  gtag('js', new Date());
				  gtag('config', 'G-YBTR3X59V9' );
				  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-YBTR3X59V9"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-YBTR3X59V9');</script><link rel="canonical" href="https://knowledge.fourier.industries/programming-the-sstuino-ii-10-2.html"><link rel="alternate" type="application/atom+xml" href="https://knowledge.fourier.industries/feed.xml"><link rel="alternate" type="application/json" href="https://knowledge.fourier.industries/feed.json"><meta property="og:title" content="From Blocks to Code, Part II"><meta property="og:image" content="https://knowledge.fourier.industries/media/website/logo-3.png"><meta property="og:site_name" content="FourierIndustries Knowledge Base"><meta property="og:description" content="In this tutorial, we are going to explore functions, understand&hellip;"><meta property="og:url" content="https://knowledge.fourier.industries/programming-the-sstuino-ii-10-2.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://knowledge.fourier.industries/assets/css/style.css?v=475fbb5a3cf77d9829324a8d8d83c76e"><link rel="stylesheet" href="https://knowledge.fourier.industries/assets/css/prism-dark.css?v=77202604b9c81e0cfc60210c4810d09c"><link rel="preconnect" href="https://-dsn.algolia.net" crossorigin><link rel="stylesheet" href="https://knowledge.fourier.industries/assets/css/docsearch.css?v=5f509c0dccaf0aaffb9fc8c0b9e1351c"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://knowledge.fourier.industries/programming-the-sstuino-ii-10-2.html"},"headline":"From Blocks to Code, Part II","datePublished":"2022-04-04T14:43","dateModified":"2022-04-22T19:36","image":{"@type":"ImageObject","url":"https://knowledge.fourier.industries/media/website/logo-3.png","height":100,"width":320},"description":"In this tutorial, we are going to explore functions, understand&hellip;","author":{"@type":"Person","name":"Goh Qian Zhe","url":"https://knowledge.fourier.industries/authors/goh-qian-zhe/"},"publisher":{"@type":"Organization","name":"FourierIndustries LLP","logo":{"@type":"ImageObject","url":"https://knowledge.fourier.industries/media/website/logo-3.png","height":100,"width":320}}}</script></head><body><header class="header" id="js-header"><a class="logo" href="https://knowledge.fourier.industries/"><img src="https://knowledge.fourier.industries/media/website/logo-3.png" alt="FourierIndustries Knowledge Base"></a></header><main><div class="container container--with-sidebar"><div class="sidebar js-sidebar"><div class="sidebar__search"><div id="docsearch"></div></div><nav class="sidebar__menu"><ul class="js-sidebar-menu"><li class="has-submenu"><span>SSTuino Series</span><ul><li class="has-submenu"><span>SSTuino II</span><ul><li><a href="https://knowledge.fourier.industries/sstuino-innovators-kit-v2.html">Introduction</a></li><li><a href="https://knowledge.fourier.industries/sstuino-ii-essentials-track.html">Essentials Track</a></li><li><a href="https://knowledge.fourier.industries/work-in-progress.html">Advanced Scientific Track</a></li><li><a href="https://knowledge.fourier.industries/work-in-progress.html">Advanced IoT Track</a></li><li><a href="https://knowledge.fourier.industries/work-in-progress.html">Advanced App Track</a></li></ul></li><li class="has-submenu"><span>SSTuino Classic</span><ul><li><a href="https://knowledge.fourier.industries/home.html">Introduction</a></li><li><a href="https://knowledge.fourier.industries/home.html">Essentials Track</a></li></ul></li></ul></li><li class="has-submenu"><span>Exploring Further</span><ul><li><a href="https://knowledge.fourier.industries/work-in-progress.html">Sensors</a></li><li><a href="https://knowledge.fourier.industries/work-in-progress.html">Actuators</a></li></ul></li><li class="has-submenu"><span>Browse by Level</span><ul><li><a href="https://knowledge.fourier.industries/work-in-progress.html">Beginner</a></li><li><a href="https://knowledge.fourier.industries/work-in-progress.html">Intermediate</a></li><li><a href="https://knowledge.fourier.industries/work-in-progress.html">Advanced</a></li></ul></li></ul></nav></div><div class="content content--center"><article class="post"><h1>From Blocks to Code, Part II</h1><div class="post__entry"><p>In this tutorial, we are going to explore functions, understand the limitations of block coding, and how to "multitask" your SSTuino.</p><div class="post__toc"><h3>Table of Contents</h3><ul><li><a href="#mcetoc_1fvmoha0d3">Functions</a><ul><li><a href="#mcetoc_1fvp2st7fc">Ultrasonic Distance Sensor Example</a></li><li><a href="#mcetoc_1fvp2st7fd">Potentiometer Example</a></li></ul></li><li><a href="#mcetoc_1fvp2st7fe">Limitations of Block Code</a></li><li><a href="#mcetoc_1fvp2st7ff">"Multitasking" your SSTuino</a><ul><li><a href="#mcetoc_1fvp2st7fg">millis() instead of delay()</a></li><li><a href="#mcetoc_1fvpo53oi1c">Ultrasonic Sensor and Buzzer Example</a></li></ul></li><li><a href="#mcetoc_1fvp2st7fh">Resources and Going Further</a></li></ul></div><h2 id="mcetoc_1fvmoha0d3">Functions</h2><p>Here are the 3 basic parts that you would have in the code.</p><figure class="post__image"><img loading="lazy" src="https://knowledge.fourier.industries/media/posts/24/SSTuinoIoT8.png" sizes="(max-width: 749px) 100vw, 749px" srcset="https://knowledge.fourier.industries/media/posts/24/responsive/SSTuinoIoT8-xs.png 300w, https://knowledge.fourier.industries/media/posts/24/responsive/SSTuinoIoT8-sm.png 480w, https://knowledge.fourier.industries/media/posts/24/responsive/SSTuinoIoT8-md.png 749w" alt="" width="897" height="387"></figure><p>However, you can separate code into functions, which create modular pieces of code that perform a defined task. Here are some advantages when you standardise code fragments into functions:</p><ul><li>Functions help the programmer to stay organised and help to conceptualise the program.</li><li>Functions codify one function in one place so that it only has to be thought out and debugged once.</li><li>If the code has to be changed, functions also reduce the errors in modification.</li></ul><p>Functions can also help to have smaller code, especially if particular lines of code are used repeatedly in the program. Although functions have many advantages, do take note that Arduino still requires <code><strong>void setup()</strong></code> and <code><strong>void loop()</strong></code> for the program to work. You can place your additional functions outside of them. Now let‚Äôs make some functions with the previous examples!</p><h3 id="mcetoc_1fvp2st7fc">Ultrasonic Distance Sensor Example</h3><p>We are going to continue to use this circuit from our previous example.</p><p class="msg msg--warning"><strong>Warning:</strong> To prevent damage to your Learning Device or your components, please <strong>do not connect the SSTuino to your LD or power supply</strong> when you are wiring up your circuit.¬†</p><figure class="post__image"><img loading="lazy" src="https://knowledge.fourier.industries/media/posts/24/arduinoPot19.png" sizes="(max-width: 749px) 100vw, 749px" srcset="https://knowledge.fourier.industries/media/posts/24/responsive/arduinoPot19-xs.png 300w, https://knowledge.fourier.industries/media/posts/24/responsive/arduinoPot19-sm.png 480w, https://knowledge.fourier.industries/media/posts/24/responsive/arduinoPot19-md.png 749w" alt="" width="1758" height="970"></figure><p>Here is an edited text version of the blocks code from TinkerCAD. Firstly the device initialises the Serial Monitor. Note that it does not declare the pins inside <code>setup()</code>. We will cover that in the function! üòÅ</p><pre><code class="language-cpp">
void setup() 
{
  Serial.begin(9600);
}
</code></pre><p>Now we will do up the code in <code>loop()</code>. We will make the serial monitor print the time taken for the sound wave to bounce back using the function <code>readUltrasonicDistance(5,6)</code> in microseconds and multiply that by half the speed of sound to display the distance in cm.</p><p class="msg msg--info"><strong>Tip: </strong>The speed of sound is 0.0343 centimetre/microsecond. We half that to 0.01723 because the time taken for the sound to bounce back is 2x the total distance (time taken to the object + time taken from the object)</p><pre><code class="language-cpp">
void loop()
{
  Serial.println(0.01723 * readUltrasonicDistance(5, 6));
}
</code></pre><p>And finally the function! We declare it so that we can use it in the calculation in <code>loop()</code>. The function essentially tells the sensor to "fire" the ultrasonic wave and read the time taken for it to travel to and fro.</p><pre><code class="language-cpp">
long readUltrasonicDistance(int triggerPin, int echoPin)
{
  pinMode(triggerPin, OUTPUT);  // Clear the trigger
  digitalWrite(triggerPin, LOW);
  delayMicroseconds(2);
  // Sets the trigger pin to HIGH state for 10 microseconds
  digitalWrite(triggerPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(triggerPin, LOW);
  pinMode(echoPin, INPUT);
  // Reads the echo pin, and returns the sound wave travel time in microseconds
  return pulseIn(echoPin, HIGH);
}
</code></pre><p>Let's try this out in the Arduino IDE! What other functions would you like to add to this code?</p><h3 id="mcetoc_1fvp2st7fd">Potentiometer Example</h3><p>Let's try out another simple example with the Potentiometer! Set up the circuit as shown:</p><p class="msg msg--warning"><strong>Warning:</strong> To prevent damage to your Learning Device or your components, please <strong>do not connect the SSTuino to your LD or power supply</strong> when you are wiring up your circuit.¬†</p><figure class="post__image"><img loading="lazy" src="https://knowledge.fourier.industries/media/posts/24/arduinoPot4.png" sizes="(max-width: 749px) 100vw, 749px" srcset="https://knowledge.fourier.industries/media/posts/24/responsive/arduinoPot4-xs.png 300w, https://knowledge.fourier.industries/media/posts/24/responsive/arduinoPot4-sm.png 480w, https://knowledge.fourier.industries/media/posts/24/responsive/arduinoPot4-md.png 749w" alt="" width="1159" height="563"></figure><p>Head over to the Arduino IDE and set up the code. First, let‚Äôs open the serial port, input and output pins:</p><pre><code class="language-cpp">
void setup()
{
    Serial.begin(9600);
    pinMode(A0, INPUT);
    pinMode(6, OUTPUT);
}
</code></pre><p>Next, let's leave <code><strong>void loop()</strong></code> alone for a bit üòÜ and set up functions! You can name your functions whatever you want, as long as it‚Äôs a single word and does not start with numbers.</p><pre><code class="language-cpp">
void pwmLed()
{
    analogWrite(6, (analogRead(A0) / 4));
}

void helloWorld()
{
    Serial.println("Hello, World!");
}
</code></pre><p>With this, we have just created 2 functions! Let us place them inside <code><strong>void loop()</strong></code></p><pre><code class="language-cpp">
void loop()
{
  helloWorld();
  pwmLed();
}
</code></pre><p>The advantage of using functions in this scenario is that if I would like to not make a section of code run, I do not need to comment out all the lines inside <code><strong>void loop()</strong></code>. Instead, I just have to comment out the function like this!</p><pre><code class="language-cpp">
void loop()
{
  //helloWorld(); // This code will not be run.
  pwmLed();
}
</code></pre><h2 id="mcetoc_1fvp2st7fe">Limitations of Block Code</h2><p>Programming with blocks is super simple! Just plop them in and you are good to go! Block coding is a great tool to get people started with little to no programming knowledge. However, as we move to more advanced tutorials like the Internet of Things, there are many functions not available to us in block coding. While we love introductory tools such as TinkerCAD's block coding functionality, we would like our students to move on to text-based programming languages too!</p><p>Here are some limitations of block code:</p><ul><li>Cannot use code that other people wrote (aka libraries)</li><li>Inability to use sensors that are not supported by the platform</li><li>Block coding uses delays, which is no good if you want to do multiple things at once</li></ul><h2 id="mcetoc_1fvp2st7ff">"Multitasking" your SSTuino</h2><p>Let's make the device "multitask"! For the examples that we have covered so far, we have always used <code><strong>delay()</strong></code> to say light up an LED for 1 second. However, although <code><strong>delay()</strong></code> is handy and works for basic examples, it shouldn't be used in the real world...</p><p>Wait, what? ü§Ø</p><p>Why shouldn't we use <code><strong>delay()</strong></code>? That is because delay is a blocking function. For example, when you do <code><strong>delay(1000)</strong></code>, the Arduino stops on that line for one second. Blocking functions prevent a program from doing anything else until that particular task has been completed. If you need multiple tasks to occur at the same time, you simply cannot use <strong><code>delay()</code></strong>. If your program requires you to constantly read data (e.g. Ultrasonic Sensor), you should avoid using the delay function.</p><h3 id="mcetoc_1fvp2st7fg">millis() instead of delay()</h3><p>Here comes <code><strong>millis()</strong></code> to the rescue! ü•≥ When called, it returns the number of milliseconds that have passed since the program first started. By doing some simple math and comparison, you can verify how much time has passed without blocking your code! Let‚Äôs take a look at the Blink sketch that does not use the <code><strong>delay()</strong></code> function:</p><pre><code class="language-cpp">
// constants won't change. Used here to set a pin number :
const int ledPin = 13; // the number of the LED pin

// Variables will change :
int ledState = LOW; // ledState used to set the LED

// Generally, you should use "unsigned long" for variables that hold time
// The value will quickly become too large for an int to store
unsigned long previousMillis = 0; // will store last time LED was updated

// constants won't change :
const long interval = 1000; // interval at which to blink (milliseconds)

void setup()
{
    // set the digital pin as output:
    pinMode(ledPin, OUTPUT);
}

void loop()
{
    // here is where you'd put code that needs to be running all the time.

    // check to see if it's time to blink the LED; that is, if the
    // difference between the current time and the last time you blinked
    // the LED is bigger than the interval at which you want to
    // blink the LED.
    unsigned long currentMillis = millis();

    if (currentMillis - previousMillis &gt;= interval)
    {
        // save the last time you blinked the LED
        previousMillis = currentMillis;

        // if the LED is off turn it on and vice-versa:
        if (ledState == LOW)
        {
            ledState = HIGH;
        }
        else
        {
            ledState = LOW;
        }

        // set the LED with the ledState of the variable:
        digitalWrite(ledPin, ledState);
    }
}
</code></pre><p>How the code works is that it subtracts the previously recorded time (<code>previousMillis</code>) from the current time (<code>currentMillis</code>). If the remainder is greater than the interval (1000 milliseconds), the program updates the <code>previousMillis</code> variable to the current time, and either turns the LED on or off.</p><p>As the program is non-blocking, any code that is added outside of the first if statement should work correctly. You can now add other tasks and your LED will blink every second!</p><p>Using the <code><strong>millis()</strong></code> function does take a bit more work than using the <code><strong>delay()</strong></code> function but will be worth it if the program needs to multitask.</p><h3 id="mcetoc_1fvpo53oi1c">Ultrasonic Sensor and Buzzer Example</h3><p>Let's wire up your circuit as so!</p><p class="msg msg--warning"><strong>Warning:</strong> To prevent damage to your Learning Device or your components, please <strong>do not connect the SSTuino to your LD or power supply</strong> when you are wiring up your circuit.¬†</p><figure class="post__image"><img loading="lazy" src="https://knowledge.fourier.industries/media/posts/24/arduinoPot39.png" sizes="(max-width: 749px) 100vw, 749px" srcset="https://knowledge.fourier.industries/media/posts/24/responsive/arduinoPot39-xs.png 300w, https://knowledge.fourier.industries/media/posts/24/responsive/arduinoPot39-sm.png 480w, https://knowledge.fourier.industries/media/posts/24/responsive/arduinoPot39-md.png 749w" alt="" width="1834" height="985"></figure><p>Next, head over to the Arduino IDE where we will program the ultrasonic sensor to:</p><ul><li>trigger the ultrasonic wave every 1 millisecond</li><li>print the distance to the serial monitor every 1 second</li><li>turn on and off a buzzer every second if the distance is less than 30cm</li></ul><pre><code class="language-cpp">
const int trigPin = 5; // set pin variables
const int echoPin = 6;
const int buzzerPin = 13;

int trigState = LOW;              // state of trigPin
int interval = 1;                 // interval in milliseconds at which trigPin turns on
int interval2 = 1000;             // time in milliseconds at which the distance is printed in serial monitors
int printState = LOW;             // whether or not to print distance
int buzzer = LOW;                 // whether or not buzzer is on
unsigned long previousMillis = 0; // microsecond at which the pin was last writen

void setup()
{
    Serial.begin(9600);       // begin serial communication
    pinMode(trigPin, OUTPUT); // set pinmodes
    pinMode(echoPin, INPUT);
    pinMode(buzzerPin, OUTPUT);
}

void loop()
{
    unsigned long currentMillis = millis(); // time in milliseconds from which the code was started
    if (currentMillis - previousMillis &gt;= interval)
    {                                   // check "blink without delay" code
        previousMillis = currentMillis; //
        if (trigState == LOW)
        {
            trigState = HIGH;
        }
        else
        {
            trigState = LOW;
        }
    }
    // printing speed in serial monitor at an interval of 1s
    if (currentMillis - previousMillis &gt;= interval2)
    { // check "blink without delay" code
        previousMillis = currentMillis;
        if (printState == LOW)
        {
            printState = HIGH;
        }
        else
        {
            printState = LOW;
        }
    }
    digitalWrite(trigPin, trigState);  // Fire the pulse to measure distance
    int duration, distance;            // variables
    duration = pulseIn(echoPin, HIGH); // Measure the time taken for the pulse
    distance = duration * 0.01723;     // Calculate speed
    if (printState = HIGH)
    { // print the data to the serial monitor
        Serial.print(distance);
        Serial.println("cm");
    }

    if (distance &lt; = 30)
    { // If distance &lt;30cm, buzzer will sound at an interval of 1s.
        if (currentMillis - previousMillis &gt;= interval2)
        { // check "blink without delay" code
            previousMillis = currentMillis;
            if (buzzer == LOW)
            {
                buzzer = HIGH;
                digitalWrite(buzzerPin, HIGH);
            }
            else
            {
                buzzer = LOW;
                digitalWrite(buzzerPin, LOW);
            }
        }
    }
    else
    {
        digitalWrite(buzzerPin, LOW);
    }
}
</code></pre><h2 id="mcetoc_1fvp2st7fh">Resources and Going Further</h2><p>If you want to know more about how to use functions, and how to avoid using <code>delay()</code> to control timing on an Arduino, check out the articles below.</p><ul><li><a href="https://docs.arduino.cc/learn/programming/functions" target="_blank" rel="noopener noreferrer">Arduino: Using functions in a sketch</a></li><li><a href="https://randomnerdtutorials.com/why-you-shouldnt-always-use-the-arduino-delay-function/" target="_blank" rel="noopener noreferrer">Random Nerd Tutorials: Why you shouldn't always use the Arduino delay function</a></li><li><a href="https://create.arduino.cc/projecthub/Arduino_Scuola/limitations-of-delay-how-to-do-timers-correctly-833e9e" target="_blank" rel="noopener noreferrer">Arduino Project Hub: Limitations of delay() &amp; how to do timers correctly</a></li></ul><p><a href="https://knowledge.fourier.industries/programming-the-sstuino-ii-10.html" class="btn btn--outline">‚¨ÖÔ∏è Back</a><a style="float: right;" href="https://knowledge.fourier.industries/programming-the-sstuino-ii-10-3.html" class="btn btn--green">Next ‚û°Ô∏è</a></p></div></article></div></div></main><footer class="footer"><div><a class="footer__logo" href="https://knowledge.fourier.industries/"><img src="https://knowledge.fourier.industries/media/website/logo-3.png" alt="FourierIndustries Knowledge Base"></a></div><div><div class="footer__copy">Copyright ¬© FourierIndustries LLP | Powered by Publii</div><div class="footer__social"></div></div></footer><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'overlay',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true
   };</script><script defer="defer" src="https://knowledge.fourier.industries/assets/js/scripts.min.js?v=19238bf2fc84904070fcd40cc63434e6"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script defer="defer" src="https://knowledge.fourier.industries/assets/js/prism.js?v=3f40a85448916137440d70109f6ef21e"></script><script defer="defer" src="https://knowledge.fourier.industries/assets/js/prism-line-numbers.min.js?v=13275d3ac10d7028cf6a6f5da276f68c"></script><script defer="defer" src="https://knowledge.fourier.industries/assets/js/clipboard.min.js?v=ad98572d415d2f2452845a6068a913c0"></script><script defer="defer" src="https://knowledge.fourier.industries/assets/js/prism-copy-to-clipboard.min.js?v=57b50bd6f44169b9bab177133c984653"></script><script src="https://knowledge.fourier.industries/assets/js/docsearch.min.js?v=d59ba9b8392f352d8127a805b3df99b9"></script><script>docsearch({
         container: '#docsearch',
         appId: '',
         indexName: '',
         apiKey: '',
         debug: false
      });</script></body></html>